name: 'Setup Vanilla Kubernetes (kubeadm)'
description: 'Install Kubernetes using kubeadm with containerd or cri-o'
inputs:
  container-runtime:
    description: 'Container runtime to use (containerd or crio)'
    required: false
    default: 'containerd'
  runtime-version:
    description: 'Container runtime version (major.minor or "latest" for newest release including beta)'
    required: false
    default: 'latest'
runs:
  using: 'composite'
  steps:
    - name: Free up disk space
      shell: bash
      run: |
        echo "üßπ Removing unnecessary directories to free up disk space..."
        sudo rm -rf /usr/local/.ghcup
        sudo rm -rf /opt/hostedtoolcache/CodeQL
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /opt/ghc
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf "$AGENT_TOOLSDIRECTORY"
        sudo rm -rf /usr/lib/jvm
        sudo rm -rf /usr/share/swift
        sudo rm -rf /usr/local/share/powershell
        sudo rm -rf /usr/local/julia*
        sudo rm -rf /opt/az
        sudo rm -rf /usr/local/share/chromium
        sudo rm -rf /opt/microsoft
        sudo rm -rf /opt/google
        sudo rm -rf /usr/lib/firefox
        echo "‚úÖ Disk space freed up"
        df -h / | grep -v Filesystem

    - name: Prepare system
      shell: bash
      run: |
        echo "üîß Preparing system for Kubernetes..."
        
        # Install system dependencies
        sudo apt-get update
        sudo apt-get -y install runc
        
        # Load required kernel modules
        sudo modprobe overlay
        sudo modprobe br_netfilter
        
        # Set network parameters
        sudo sysctl -w net.bridge.bridge-nf-call-iptables=1
        sudo sysctl -w net.ipv4.ip_forward=1
        sudo sysctl -w net.bridge.bridge-nf-call-ip6tables=1
        
        # Disable swap
        sudo swapoff -a
    
    - name: Install container runtime
      shell: bash
      run: |
        echo "üì¶ Installing ${{ inputs.container-runtime }} ${{ inputs.runtime-version }}..."
        
        RUNTIME="${{ inputs.container-runtime }}"
        VERSION="${{ inputs.runtime-version }}"
        
        if [ "${RUNTIME}" = "containerd" ]; then
          # Install containerd
          ARCH=$(uname -m)
          case "${ARCH}" in
            x86_64) ARCH="amd64" ;;
            aarch64) ARCH="arm64" ;;
          esac
          
          # Setup GitHub API authentication if available
          CURL_AUTH_HEADER=""
          if [ -n "${GH_TOKEN:-}" ]; then
            CURL_AUTH_HEADER="Authorization: Bearer ${GH_TOKEN}"
          fi
          
          # Determine full version
          if [ "${VERSION}" = "latest" ]; then
            # Get the absolute latest release (including beta/RC)
            # Use /releases (not /releases/latest) to get the very latest including pre-releases
            # Note: Filter out API releases (tag_name contains "api/")
            echo "üîç Fetching latest containerd release from GitHub API..."
            if [ -n "${CURL_AUTH_HEADER}" ]; then
              API_RESPONSE=$(curl -sSf -H "${CURL_AUTH_HEADER}" https://api.github.com/repos/containerd/containerd/releases)
            else
              API_RESPONSE=$(curl -sSf https://api.github.com/repos/containerd/containerd/releases)
            fi
            
            if [ -z "${API_RESPONSE}" ]; then
              echo "‚ùå Failed to fetch containerd releases from GitHub API"
              exit 1
            fi
            
            # Filter out API releases (those with "api/" in tag_name) and get the first binary release
            FULL_VERSION=$(echo "${API_RESPONSE}" | jq -r '[.[] | select(.tag_name | contains("api/") | not)][0].tag_name // "ERROR"')
            
            if [ "${FULL_VERSION}" = "ERROR" ] || [ -z "${FULL_VERSION}" ]; then
              echo "‚ùå Failed to find a valid containerd binary release"
              echo "üîç Available releases (first 5):"
              echo "${API_RESPONSE}" | jq -r '.[0:5][] | {tag_name, name, prerelease}'
              exit 1
            fi
            
            # Remove 'v' prefix
            FULL_VERSION=$(echo "${FULL_VERSION}" | sed 's/^v//')
            echo "‚ÑπÔ∏è  Using latest containerd release: v${FULL_VERSION}"
          else
            # Get latest patch version for the specified major.minor
            # Note: Filter out API releases (tag_name contains "api/")
            echo "üîç Fetching containerd ${VERSION}.x releases from GitHub API..."
            if [ -n "${CURL_AUTH_HEADER}" ]; then
              API_RESPONSE=$(curl -sSf -H "${CURL_AUTH_HEADER}" https://api.github.com/repos/containerd/containerd/releases)
            else
              API_RESPONSE=$(curl -sSf https://api.github.com/repos/containerd/containerd/releases)
            fi
            
            if [ -z "${API_RESPONSE}" ]; then
              echo "‚ùå Failed to fetch containerd releases from GitHub API"
              exit 1
            fi
            
            # Filter out API releases and find matching version
            FULL_VERSION=$(echo "${API_RESPONSE}" | jq -r '[.[] | select(.tag_name | contains("api/") | not)] | .[].tag_name' | grep "^v${VERSION}\." | head -1 | sed 's/^v//')
            
            if [ -z "${FULL_VERSION}" ]; then
              echo "‚ùå No containerd ${VERSION}.x release found"
              echo "üîç Available ${VERSION}.x releases:"
              echo "${API_RESPONSE}" | jq -r '[.[] | select(.tag_name | contains("api/") | not) | select(.tag_name | startswith("v'${VERSION}'."))] | .[0:5][] | .tag_name'
              exit 1
            fi
            
            echo "‚ÑπÔ∏è  Using latest ${VERSION}.x release: v${FULL_VERSION}"
          fi
          
          if [ -z "${FULL_VERSION}" ]; then
            echo "‚ùå Failed to find containerd version matching ${VERSION}"
            exit 1
          fi
          
          echo "üì• Downloading containerd ${FULL_VERSION}..."
          curl -fsSL -o containerd.tar.gz \
            "https://github.com/containerd/containerd/releases/download/v${FULL_VERSION}/containerd-${FULL_VERSION}-linux-${ARCH}.tar.gz"
          
          sudo tar -C /usr/local -xzf containerd.tar.gz
          rm containerd.tar.gz
          
          # Install containerd systemd service
          sudo curl -fsSL -o /etc/systemd/system/containerd.service \
            https://raw.githubusercontent.com/containerd/containerd/main/containerd.service
          
          # Configure containerd
          sudo mkdir -p /etc/containerd
          containerd config default | sed -e 's/SystemdCgroup = false/SystemdCgroup = true/' | sudo tee /etc/containerd/config.toml
          
        elif [ "${RUNTIME}" = "crio" ]; then
          # Install CRI-O from package repository
          echo "üì• Installing CRI-O (version aligned with Kubernetes)..."
          
          # Get the Kubernetes version that will be installed (same as kubeadm)
          KUBERNETES_VERSION=$(curl -Ls https://dl.k8s.io/release/stable.txt | cut -d. -f-2)
          
          if [ -z "${KUBERNETES_VERSION}" ]; then
            echo "‚ùå Failed to determine Kubernetes version"
            exit 1
          fi
          
          # Use CRI-O version matching the Kubernetes major.minor version
          # K8s v1.31 -> CRI-O v1.31 (keep the 'v' prefix for opensuse repos)
          CRIO_VERSION="${KUBERNETES_VERSION}"
          
          echo "‚ÑπÔ∏è  Kubernetes version: ${KUBERNETES_VERSION}"
          echo "‚ÑπÔ∏è  Checking for CRI-O version: ${CRIO_VERSION} (aligned with K8s)"
          
          # Check if CRI-O repository exists for this version
          CRIO_REPO_URL="https://download.opensuse.org/repositories/isv:/cri-o:/stable:/${CRIO_VERSION}/deb/Release.key"
          if ! curl -fsSL --head "${CRIO_REPO_URL}" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  CRI-O ${CRIO_VERSION} repository not found, finding latest available stable version..."
            
            # Setup GitHub API authentication if available
            CURL_AUTH_HEADER=""
            if [ -n "${GH_TOKEN:-}" ]; then
              CURL_AUTH_HEADER="Authorization: Bearer ${GH_TOKEN}"
            fi
            
            # Get latest stable CRI-O version from GitHub (keep the v prefix)
            echo "üîç Fetching latest stable CRI-O release from GitHub API..."
            if [ -n "${CURL_AUTH_HEADER}" ]; then
              API_RESPONSE=$(curl -sSf -H "${CURL_AUTH_HEADER}" https://api.github.com/repos/cri-o/cri-o/releases)
            else
              API_RESPONSE=$(curl -sSf https://api.github.com/repos/cri-o/cri-o/releases)
            fi
            
            if [ -z "${API_RESPONSE}" ]; then
              echo "‚ùå Failed to fetch CRI-O releases from GitHub API"
              exit 1
            fi
            
            CRIO_VERSION=$(echo "${API_RESPONSE}" | jq -r '[.[] | select(.prerelease == false)][0].tag_name')
            
            if [ -z "${CRIO_VERSION}" ]; then
              echo "‚ùå Failed to find latest stable CRI-O version"
              exit 1
            fi
            
            echo "‚ÑπÔ∏è  Using latest available CRI-O version: ${CRIO_VERSION}"
          else
            echo "‚úÖ CRI-O ${CRIO_VERSION} repository found"
          fi
          
          # Install dependencies for adding repositories
          echo "üì¶ Installing dependencies..."
          sudo apt-get update
          sudo apt-get install -y software-properties-common curl
          
          # Create keyrings directory
          sudo mkdir -p /etc/apt/keyrings
          
          # Add the Kubernetes repository
          echo "üì¶ Adding Kubernetes repository (${KUBERNETES_VERSION})..."
          curl -fsSL https://pkgs.k8s.io/core:/stable:/${KUBERNETES_VERSION}/deb/Release.key | \
            sudo gpg --batch --yes --no-tty --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
          
          echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/${KUBERNETES_VERSION}/deb/ /" | \
            sudo tee /etc/apt/sources.list.d/kubernetes.list
          
          # Add the CRI-O repository
          echo "üì¶ Adding CRI-O repository (${CRIO_VERSION})..."
          curl -fsSL https://download.opensuse.org/repositories/isv:/cri-o:/stable:/${CRIO_VERSION}/deb/Release.key | \
            sudo gpg --batch --yes --no-tty --dearmor -o /etc/apt/keyrings/cri-o-apt-keyring.gpg
          
          echo "deb [signed-by=/etc/apt/keyrings/cri-o-apt-keyring.gpg] https://download.opensuse.org/repositories/isv:/cri-o:/stable:/${CRIO_VERSION}/deb/ /" | \
            sudo tee /etc/apt/sources.list.d/cri-o.list
          
          # Install CRI-O
          echo "üì¶ Installing CRI-O and dependencies..."
          sudo apt-get update
          sudo apt-get install -y cri-o cri-tools
          
          # Configure default capabilities for CRI-O
          # See: https://github.com/kata-containers/kata-containers/issues/8034
          echo "‚öôÔ∏è  Configuring CRI-O default capabilities..."
          sudo mkdir -p /etc/crio/crio.conf.d/
          printf '%s\n' \
            '[crio]' \
            'storage_option = [' \
            '        "overlay.skip_mount_home=true",' \
            ']' \
            '[crio.runtime]' \
            'default_capabilities = [' \
            '        "CHOWN",' \
            '        "DAC_OVERRIDE",' \
            '        "FSETID",' \
            '        "FOWNER",' \
            '        "SETGID",' \
            '        "SETUID",' \
            '        "SETPCAP",' \
            '        "NET_BIND_SERVICE",' \
            '        "KILL",' \
            '        "SYS_CHROOT",' \
            ']' \
            | sudo tee /etc/crio/crio.conf.d/00-default-capabilities.conf >/dev/null
          echo "‚úÖ CRI-O configuration complete"
        else
          echo "‚ùå Unsupported container runtime: ${RUNTIME}"
          exit 1
        fi
        
        # Start the container runtime
        sudo systemctl daemon-reload
        sudo systemctl enable --now ${RUNTIME}
        sudo systemctl restart ${RUNTIME}
        
        echo "‚úÖ ${RUNTIME} installed and running"
    
    - name: Install kubeadm, kubelet, kubectl
      shell: bash
      run: |
        echo "üì¶ Installing Kubernetes components..."
        
        # Get the latest stable Kubernetes version
        K8S_VERSION=$(curl -Ls https://dl.k8s.io/release/stable.txt | cut -d. -f-2)
        
        # Add the pkgs.k8s.io repo
        curl -fsSL "https://pkgs.k8s.io/core:/stable:/${K8S_VERSION}/deb/Release.key" | \
          sudo gpg --batch --yes --no-tty --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
        
        echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/${K8S_VERSION}/deb/ /" | \
          sudo tee /etc/apt/sources.list.d/kubernetes.list
        
        # Pin the packages to ensure they're downloaded from pkgs.k8s.io repo
        cat <<EOF | sudo tee /etc/apt/preferences.d/kubernetes
        Package: kubelet kubeadm kubectl cri-tools kubernetes-cni
        Pin: origin pkgs.k8s.io
        Pin-Priority: 1000
        EOF
        
        # Install the packages
        sudo apt-get update
        sudo apt-get -y install kubeadm kubelet kubectl --allow-downgrades
        sudo apt-mark hold kubeadm kubelet kubectl
        
        echo "‚úÖ Kubernetes components installed"
    
    - name: Initialize cluster with kubeadm
      shell: bash
      run: |
        echo "üöÄ Initializing Kubernetes cluster with kubeadm..."
        
        RUNTIME="${{ inputs.container-runtime }}"
        
        # Set CRI socket based on runtime
        if [ "${RUNTIME}" = "crio" ]; then
          CRI_SOCKET="unix:///var/run/crio/crio.sock"
        else
          CRI_SOCKET="unix:///run/containerd/containerd.sock"
        fi
        
        sudo kubeadm init --pod-network-cidr=10.244.0.0/16 --cri-socket="${CRI_SOCKET}"
        
        mkdir -p $HOME/.kube
        sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
        sudo chown $(id -u):$(id -g) $HOME/.kube/config
        
        echo "‚úÖ Cluster initialized"
    
    - name: Install Flannel CNI
      shell: bash
      run: |
        echo "üì¶ Installing Flannel CNI..."
        kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml
        
        # Untaint the node to allow scheduling on control plane
        kubectl taint nodes --all node-role.kubernetes.io/control-plane- || true
        
        echo "‚úÖ Flannel installed"
    
    - name: Verify cluster
      shell: bash
      run: |
        echo "üîç Verifying Kubernetes cluster..."
        kubectl get nodes
        kubectl get pods -A
        
        # Wait for system pods to be ready (excluding completed/job pods)
        echo "‚è≥ Waiting for system pods..."
        # Wait only for Running pods (not Completed/Job pods)
        kubectl wait --for=condition=Ready pods --all -n kube-system --timeout=5m \
          --field-selector=status.phase!=Succeeded,status.phase!=Failed || true
        
        # Verify all pods are either Running or Completed
        NOT_READY=$(kubectl get pods -n kube-system -o json | \
          jq -r '.items[] | select(.status.phase != "Running" and .status.phase != "Succeeded") | .metadata.name')
        
        if [ -n "$NOT_READY" ]; then
          echo "‚ùå Some pods are not ready:"
          echo "$NOT_READY"
          kubectl get pods -A
          exit 1
        fi
        
        echo "‚úÖ Kubernetes cluster is ready!"
        
        # Show containerd/crio version
        if command -v containerd >/dev/null; then
          echo "containerd version: $(containerd --version)"
        fi
        if command -v crio >/dev/null; then
          echo "crio version: $(crio --version)"
        fi
